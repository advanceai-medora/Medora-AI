import jwt
import time
import uuid
import requests
import json
import os
from datetime import datetime

# Configuration
IMS_BASE_URL = "https://meditabfhirsandbox.meditab.com"
IMS_FHIR_ENDPOINT = "/mps/fhir/R4"
IMS_TOKEN_ENDPOINT = "https://keycloak-qa.medpharmservices.com:8443/realms/fhir-0051185/protocol/openid-connect/token"
IMS_CLIENT_ID = "4ddd3a59-414c-405e-acc5-226c097a7060"
PRIVATE_KEY_PATH = "/var/www/medora-frontend/public/medora_private_key.pem"

# For logging
LOG_FILE = "medora_ims_integration_test.log"

def log_message(message):
    """Log messages with timestamp"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"[{timestamp}] {message}"
    print(log_entry)
    
    with open(LOG_FILE, "a") as f:
        f.write(log_entry + "\n")

def load_private_key():
    """Load the private key from file"""
    try:
        with open(PRIVATE_KEY_PATH, 'r') as f:
            return f.read()
    except Exception as e:
        log_message(f"ERROR: Failed to load private key: {str(e)}")
        exit(1)

def generate_jwt_assertion(private_key):
    """Generate a JWT assertion for client credentials grant"""
    now = int(time.time())
    jti_value = str(uuid.uuid4())
    
    payload = {
        "sub": IMS_CLIENT_ID,
        "aud": IMS_TOKEN_ENDPOINT,
        "iss": IMS_CLIENT_ID,
        "exp": now + 300,  # 5 minutes expiration
        "iat": now,
        "jti": jti_value
    }
    
    try:
        assertion = jwt.encode(payload, private_key, algorithm="RS384")
        log_message(f"Generated JWT assertion with jti: {jti_value}")
        
        # Print the JWT payload for debugging
        log_message("JWT Payload:")
        log_message(json.dumps(payload, indent=2))
        
        # Print the full JWT assertion token
        log_message("JWT Assertion Token:")
        log_message(assertion)
        
        # Save assertion to file for easy sharing
        with open("jwt_assertion_token.txt", "w") as f:
            f.write(f"JWT Assertion Token:\n{assertion}\n\n")
            f.write(f"JWT Payload:\n{json.dumps(payload, indent=2)}\n\n")
            f.write(f"Generated at: {datetime.now()}\n")
            f.write(f"JTI: {jti_value}\n")
        
        log_message("JWT assertion saved to 'jwt_assertion_token.txt' file")
        
        return assertion
    except Exception as e:
        log_message(f"ERROR: Failed to create JWT: {str(e)}")
        return None

def decode_and_verify_jwt(assertion, private_key):
    """Decode JWT for verification (optional debugging step)"""
    try:
        # Extract public key from private key for verification
        from cryptography.hazmat.primitives import serialization
        from cryptography.hazmat.primitives.serialization import load_pem_private_key
        
        private_key_obj = load_pem_private_key(private_key.encode(), password=None)
        public_key_obj = private_key_obj.public_key()
        public_pem = public_key_obj.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        # Decode without verification first to see the payload
        decoded_payload = jwt.decode(assertion, options={"verify_signature": False})
        log_message("Decoded JWT payload (without verification):")
        log_message(json.dumps(decoded_payload, indent=2))
        
        # Now verify with public key
        verified_payload = jwt.decode(assertion, public_pem, algorithms=["RS384"])
        log_message("JWT signature verification: SUCCESS")
        
        return True
    except Exception as e:
        log_message(f"JWT verification failed: {str(e)}")
        return False

def get_access_token(assertion):
    """Request an access token using the JWT assertion"""
    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    payload = {
        "client_assertion_type": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
        "grant_type": "client_credentials", 
        "client_id": IMS_CLIENT_ID,
        "client_assertion": assertion
    }
    
    try:
        log_message("Requesting access token...")
        log_message(f"Token endpoint: {IMS_TOKEN_ENDPOINT}")
        log_message(f"Client ID: {IMS_CLIENT_ID}")
        
        response = requests.post(
            IMS_TOKEN_ENDPOINT, 
            headers=headers, 
            data=payload, 
            timeout=10
        )
        
        if response.status_code == 200:
            token_data = response.json()
            log_message(f"Successfully obtained token. Expires in: {token_data.get('expires_in')} seconds")
            return token_data.get('access_token')
        else:
            log_message(f"Token request failed with status {response.status_code}")
            log_message(f"Response: {response.text}")
            return None
            
    except Exception as e:
        log_message(f"ERROR during token request: {str(e)}")
        if hasattr(e, 'response') and e.response is not None:
            log_message(f"Response status: {e.response.status_code}")
            log_message(f"Response text: {e.response.text}")
        return None

def main():
    """Main test function - focuses on JWT generation and token request"""
    log_message("=== STARTING MEDORA-IMS JWT ASSERTION TEST ===")
    
    # 1. Load private key
    private_key = load_private_key()
    if not private_key:
        return
    
    # 2. Generate JWT assertion
    assertion = generate_jwt_assertion(private_key)
    if not assertion:
        return
    
    # 3. Optional: Verify our JWT locally
    log_message("=== VERIFYING JWT LOCALLY ===")
    decode_and_verify_jwt(assertion, private_key)
    
    # 4. Try to get access token
    log_message("=== ATTEMPTING TOKEN REQUEST ===")
    access_token = get_access_token(assertion)
    if not access_token:
        log_message("Failed to obtain access token.")
        log_message("Check the 'jwt_assertion_token.txt' file to share the JWT with IMS for debugging.")
    else:
        log_message("SUCCESS: Obtained access token!")
    
    log_message("=== TEST COMPLETED ===")

if __name__ == "__main__":
    main()
